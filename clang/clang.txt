Compiler Design.

A compiler has two parts:
1) Frontend part.
2) Backend part.

Why is it divided into two parts?
1. By Keeping the same front end & attaching different back ends, one can produce a compiler for same source language on different machines. 
2. By keeping different front ends and same backend, one can compile several different languages on the same machine.

Responsibilities of frontend part:
The frontend part is responsible for preprocessing, lexical analysis, building abstract syntax tree (AST) and semantic analysis.

a) Preprocessing: Here all the conditional preprocessing takes place (#ifndef, #ifdef etc), header files are expanded, macros are expanded and comments are removed.
Generally for C/C++ files, at the end of preprocessing, a .i file is generated.
This preprocessing will take place irrespective of syntax or semantics (Preprocessing will take place even if syntax or semantics is wrong)

b) Lexical Analysis: After the preprocessing, Lexical Analysis takes place. Lexer takes in the preprocessed code and generates
tokens from the code. 
For eg., int a = 5; In this statement, ['int', 'a', '=', '5'] are tokens.

c) After the tokens are generated, An abstract syntax tree is generated. (After symantic analysis of this AST, this AST is sent to backend of the compiler where assembly and machine code is generated)
What is an Abstract Syntax Tree? IT IS BASICALLY A TREE REPRESENTATION OF OUR PROGRAM

Eg of an AST:
int a = 5;
int b = 6;
int c = a + b;

Program:
         Variable Declarator
                             Variable Declaration
                                                 a
                                                 5
         Variable Declarator
                             Variable Declaration
                                                 b
                                                 6
         Variable Declarator
                             Variable Declaration
                                                 c
                                                 +
                                                    a 
                                                    b

d) After the syntax tree is generated, A semantic analysis is performed. Whether the statements semantically makes sense.

Responsibilities of backend part:
Only if the semantic analysis is correct, The following processes take place:
a) Compiling: This is where the syntax tree (AST) is taken to generate Assembly code in .s file.
b) Assembling: After the assembly code is generated, the machine code is generated in .o file.
c) Linking: Here the linker searches for the function definitions in other source files and links with them.


Clang:
Clang is the compiler front end for languages like C, C++, Object C, Objective C++ etc.
When we build the executable for a program in clang, LLVM (Low level Virtual Machine) is used as backend.

Clang vs GCC:
The AST generated by Clang is far more readable than the AST generated by G++.
Clang supports languages like C, C++ and GCC supports many languages like java, FORTRAN etc.
Clang only supports LLVM as backend until now and GCC frontend supports many backends.

